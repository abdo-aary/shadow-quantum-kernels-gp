import math
from typing import Dict, Any, Sequence, Tuple, List

import numpy as np
import matplotlib.pyplot as plt

from data.synthetic import KernelConfig


def plot_gp_datasets(
    data: Dict[str, Any],
    kernel_cfgs: Sequence[KernelConfig],
    *,
    x_dim: int = 0,
    sort_by_x: bool = True,
) -> Tuple[plt.Figure, List[List[plt.Axes]]]:
    """
    Visualize GP samples generated by `make_dataset` for multiple kernels.

    Parameters
    ----------
    data:
        Output of `make_dataset`, i.e. a dict with keys:
          - "inputs": np.ndarray of shape (M, input_dim)
          - "labels": List[np.ndarray] of length n_kernels,
                      each of shape (M,)
    kernel_cfgs:
        Sequence of KernelConfig used to generate the labels. Must have
        the same length as data["labels"].
    x_dim:
        Which input dimension to use on the x-axis (default: 0 = first coord).
    sort_by_x:
        If True, sort the points by x before plotting so the lines look smooth.

    Returns
    -------
    fig, axes:
        Matplotlib figure and 2D list of Axes objects (shape: n_rows Ã— n_cols).
    """
    X = data["inputs"]
    labels = data["labels"]

    X = np.asarray(X)
    M, d = X.shape

    if len(labels) != len(kernel_cfgs):
        raise ValueError(
            f"Number of label vectors ({len(labels)}) does not match "
            f"number of kernel_cfgs ({len(kernel_cfgs)})."
        )

    if not (0 <= x_dim < d):
        raise ValueError(f"x_dim must be in [0, {d-1}], got {x_dim}.")

    x = X[:, x_dim]
    n_kernels = len(kernel_cfgs)

    # Determine a near-square grid
    n_cols = math.ceil(math.sqrt(n_kernels))
    n_rows = math.ceil(n_kernels / n_cols)

    fig, axes = plt.subplots(
        n_rows, n_cols,
        figsize=(4 * n_cols, 3 * n_rows),
        squeeze=False,
        sharex=True,
    )

    if sort_by_x:
        idx = np.argsort(x)
        x_plot = x[idx]
        labels_sorted = [np.asarray(y)[idx] for y in labels]
    else:
        x_plot = x
        labels_sorted = [np.asarray(y) for y in labels]

    for k, (cfg, y_k) in enumerate(zip(kernel_cfgs, labels_sorted)):
        r = k // n_cols
        c = k % n_cols
        ax = axes[r][c]

        # Use both scatter and line for clarity, with default colors
        ax.plot(x_plot, y_k, marker="o", linestyle="-", linewidth=1.0, markersize=3)
        # Title from config name if present, otherwise kernel_type
        title = getattr(cfg, "name", None) or cfg.kernel_type
        ax.set_title(title)

        if r == n_rows - 1:
            ax.set_xlabel(f"$x_{x_dim + 1}$")
        ax.set_ylabel("$y$")

    # Hide any unused axes (if grid not exactly filled)
    for k in range(n_kernels, n_rows * n_cols):
        r = k // n_cols
        c = k % n_cols
        fig.delaxes(axes[r][c])

    fig.tight_layout()
    return fig, axes
